# 微前端
## 为什么要用微前端

## 微前端中注入权限如何控制

## 微前端解决方案 qiankun？JS沙箱的原理？样式隔离的原理
- qiankun是基于single-spa封装的，提供了开箱即用的API，使得微应用的接入像使用iframe一样简单，实现把应用改造的工作量降到最低。并且主应用和微应用都是技术栈无关的。解决开发中的两个问题：第一是空间上不同团队的协同开发不必统一技术栈，第二是时间上不同版本技术栈的升级和维护无需统一。
- JS沙箱
- 快照沙箱：在应用沙箱挂载和卸载的时候记录快照，在应用切换的时候快照恢复环境。qiankun的快照沙箱主要基于diff实现，主要用于不支持window.Proxy的低版本浏览器，而且也只适合单个实例的子应用，且会污染全局window
- 代理沙箱：qiankun基于es6的Proxy实现了两种应用场景不同的沙箱，一种是legacySandbox(单例),一种是proxySandbox(多例)。因为都是基于Proxy实现的，所以都称为代理沙箱。
单例沙箱：同样会对window造成污染，但是性能比快照沙箱好，不用遍历window对象
多例沙箱：不会污染全局window并支持多个子应用同时加载。
- 样式隔离：微前端框架里面可能会遇到的样式冲突有两种，一种是主子应用样式冲突，另一种是子应用之间的样式冲突。
动态样式表：qiankun自动实现子应用切换子应用样式动态切换，能够保证你在单应用模式下子应用与子应用之间不会冲突。
工程化手段：可以通过手动的方式确保主应用和子应用之间的样式隔离，比如给主应用的所有样式添加一个前缀；也可以通过配置{sandbox: {experimentalStyleIsolation: true}的方式开启运行时的scoped css 功能，从而解决应用间的样式隔离问题。
严格样式隔离：默认情况下沙箱可以确保单实例场景之间的样式隔离，但是无法确保主应用跟子应用、或者多实例场景的子应用样式隔离。当配置为{strictStyleIsolation: true}时表示开启严格的样式隔离模式。这种模式下qiankun会为每个微应用的容器包裹上一个shadow dom节点，从而确保微应用的样式不会对全局造成影响

## qiankun的特性是什么，有没有看过single-spa的内部实现方式

## qiankun配置应用入口后，entry是如何实现应用的路由的

## qiankun底层实现原理

## webpack5 模块联邦如何实现

## 将微前端做到极致
- qiankun方案
基于single-spa的微前端方案
特点：
1. html entry的方式引入子应用，相比js entry降低了应用的改造成本
2. 完备的沙箱方案，js沙箱做了snapshotsandbox、legacysandbox、proxysandbox三套渐进增强的方案，css沙箱做了strictStyleIsoLation、experimentalstyleisolation两套适用不同场景的方案
3. 做了静态资源预加载能力
不足：
1. 适配成本高，工程化、生命周期、静态资源路径、路由等都要做一系列的适配工作
2. css沙箱采用严格隔离会有各种问题，js沙箱在某些场景下执行性能下降严重
3. 无法同时激活多个子应用，也不支持子应用保活
- micro-app 方案
micro-app 是基于 webcomponent + qiankun sandbox 的微前端方案。
特点：
1. 使用 webcomponet 加载子应用相比 single-spa 这种注册监听方案更加优雅；
2. 复用经过大量项目验证过 qiankun 的沙箱机制也使得框架更加可靠；
3. 组件式的 api 更加符合使用习惯，支持子应用保活；
4. 降低子应用改造的成本，提供静态资源预加载能力；
不足：
1. 接入成本较 qiankun 有所降低，但是路由依然存在依赖；
2. 多应用激活后无法保持各子应用的路由状态，刷新后全部丢失；
3. css 沙箱依然无法绝对的隔离，js 沙箱做全局变量查找缓存，性能有所优化；
4. 支持 vite 运行，但必须使用 plugin 改造子应用，且 js 代码没办法做沙箱隔离；
5. 对于不支持 webcompnent 的浏览器没有做降级处理；
- EMP方案
基于webpack5 module federation的微前端方案
特点：
1. webpack联邦编译可以保证所有子应用依赖解耦
2. 应用间去中心化的调用、共享模块
3. 模块远程ts支持
不足：
1. webpack强依赖，老旧项目不友好
2. 没有有效的css沙箱和js沙箱，需要靠用户自觉
3. 子应用保活、多应用激活无法实现
4. 主、子应用的路有可能发生冲突
- 无界方案
基于webcomponent容器+iframe沙箱，能够完善的解决适配成本、样式隔离、运行性能、页面白屏、子应用通信、子应用保活、多应用激活、vite框架支持、应用共享等用户核心诉求
成本低：
主要体现在主应用的使用成本、子应用的适配成本两个方面
子应用适配成本：
子应用首先需要做支持跨域请求改造，这个是所有微前端框架运行的前提
速度快：
无界微前端非常快，主要体现在首屏打开快、运行速度快两个方面
首屏打开快：
无界微前端不仅能够做到静态资源的预加载，还可以做到子应用的预执行
运行速度快：
子应用的js在iframe内运行，由于iframe是一个天然的js运行沙箱，所以无需采用with这种方式来指定子应用的执行上下文，从而避免由于采用with语句执行子应用代码而导致的性能下降
原生隔离：
1. css沙箱隔离
无界将子应用的dom放置在webcomponent + shadowdom的容器中，除了可继承的css属性外，实现了应用之间css的原生隔离
2. js沙箱隔离
无界将子应用的js放置在iframe中运行，实现了应用之间window、document、location、history的完全解耦和隔离
3. js沙箱和css沙箱连接
底层采用proxy + Object.defineproperty的方式将js-iframe中对dom操作劫持代理到webcomponent shadowRoot容器中，开发者无感知也无需关心
功能强大：
子应用保活、子应用嵌套、多应用激活、去中心化通信、生命周期、插件系统、vite框架支持、兼容ie9、应用共享