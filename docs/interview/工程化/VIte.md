## 什么是Vite
- Vite是新一代的前端构建工具
Vite核心原理
- Vite核心原理利用浏览器现在已经支持的ES6的import，碰到import就会发送一个HTTP请求去加载文件
- Vite启动一个Koa服务器拦截这些请求，并在后端进行相应的处理将项目中使用的文件通过简单的分解与整合，然后再以ESM的格式返回给浏览器
- Vite整个过程中没有对文件进行打包编译，做到了真正的按需加载，所以其运行速度比原始的webpack开发编译速度快出很多
它具有以下特点：
- 快速的冷启动：采用 No Bundle 和 esbuild预构建，速度快于webpack
- 高效的热更新：基于ESM实现，同时利用HTTP头来加速整个页面的重新加载，增加缓存策略；源码模块使用协商，依赖模块使用强缓，因此一旦被缓存它们将不需要再次请求。
- 基于rollup打包，生产环境下由于esbuild对CSS和代码分割并使用rollup打包
基于ESM的Dev server
- 在Vite出来之前，传统的打包工具如webpack是先解析依赖、打包构建再启动开发服务器，Dev Server必须等待所有模块构建完成后才能启动，当我们修改了bundle模块中的一个子模块，整个bundle文件都会重新打包然后输出。项目应用越大，启动时间越长
- 而Vite利用浏览器对ESM的支持，当import模块时，浏览器就会下载被导入的模块。先启动开发服务器，当代码执行到模块加载时再请求对应模块的文件，本质上是实现了动态加载
基于ESM的HMR热更新
所有的HMR原理：
目前所有的打包工具实现热更新的思路都大同小异：主要通过webSocket创建浏览器和服务器的通信监听文件的改变，当文件被修改时，服务端发送消息通知客户端修改相应的代码，客户端对应不同的文件进行不同的操作的更新
Vite的表现：
- Vite监听文件系统的变更，只要对发生变更的模块重新加载，这样HMR更新速度就不会因为应用体积的增加而变慢
- 而webpack还要经历一次打包构建
- 所以HMR场景下，Vite表现也要好于webpack
基于Esbuild的依赖预编译优化
- Vite预编译之后，将文件缓存到node_modules/.vite/文件夹下
为什么需要预编译 & 预构建
- 支持非ESM格式的依赖包，Vite是基于浏览器原生支持ESM的能力实现的，因此必须将commonJs的文件提前处理，转化成ESM模块并缓存如node_modules/.vite
- 减少模块和请求数量，Vite将有许多内部模块的ESM依赖关系转换成单个模块，以提高后续页面加载性能
- 如果不使用esbuild进行预构建，浏览器每检测到一个import语句就会向服务器发送一个请求，如果一个三方包被分割成很多的文件，这样就会发送很多请求，会触发浏览器并发限制
为什么使用Esbuild
- Esbuild打包速度太快了，比类似工具快10～100倍
Esbuild为什么这么快
- Esbuild使用Go语言编写，可以直接被转化为机器语言，再启动时直接执行
- 而其余大多数的打包工具基于JS实现，是解释型语言，需要边运行边解释
- JS本质上是单线程语言，GO语言天生具有多线程的优势，充分利用CPU资源
